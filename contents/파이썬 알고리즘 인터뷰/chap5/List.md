# List 리스트

**리스트**와 딕셔너리는 파이썬에서 가장 빈번하게 쓰이므로 5장에서 따로 자세하게 다뤄본다.

파이썬의 리스트는 순서대로 저장하는 시퀀스이기 때문에 입력 순서가 유지되며, 내부적으로 ***동적 배열*** 로 구현되어 있다.

다음은 각 언어별 동적 배열을 구현한 자료형이다.

|언어| 동적 배열|
|:--:|:-----:|
|파이썬| list()|
|C++|std::vector|
|자바| ArrayList|

C++ 이나 자바에서도 동적 배열은 가장 자주 쓰이는 자료형으로, 파이썬에서도 이는 마찬가지이다.

파이썬 리스트의 장점은, 매우 다양한 기능을 제공한다는 것이다. 리스트를 사용하면 스택과 큐에 대해 고민하지 않아도 되며, 스택과 큐에서 사용 가능한 모든 연산을 함께 제공한다.

|연산|시간 복잡도|설명|
|:---:|:---:|:---:|
|len(a)|O(1)|전체 요소의 개수를 리턴|
|a[i]|O(1)|인덱스 i의 요소를 리턴|
|a[i:j]|O(k)|i부터 j 까지 슬라이스의 길이만큼인 k개의 요소를 가져온다.<br>이 경우 k개에 대한 조회가 필요하므로 O(k)|
|elem in a|O(n)|elem 요소가 존재하는지 확인<br>처음부터 순차 탐색하므로 n만큼 시간이 소요된다.|
|a.count(elem))|O(n)|elem 요소의 개수를 리턴|
|a.index(elem)|O(n)|elem 요소의 인덱스를 리턴|
|a.append(elem)|O(1)|리스트 마지막에 elem을 추가|
|a.pop()|O(1)|리스트 마지막 요소를 추출. 스택 연산|
|a.pop(0)|O(n)|리스트 첫번째 오소를 추출. 큐 연산 |
|del a[i]|O(n)|i에 따라 다름. 최악의 경우 O(n)|
|a.sort()|O(nlogn)|정렬한다. 팀소트(Timsort)를 사용하며, 최선의 경우 O(n)이다.|
|min(a),max(a)|O(n)|최대/최소값을 계산하기 위해서는 전체를 선형 탐색해야 한다.|
|a.reverse()|O(n)|뒤집는다. 리스트는 입력 순서가 유지되므로, 뒤집으면 입력 순서가 반대로 된다.|

리스트의 경우, 값의 존재 여부를 확인할 때, 정렬된 경우에는 이진 탐색이 효율적이지만, 매번 정렬이 필요하고, 보통 리스트가 정렬된 상태가 아니기 때문에, 리스트의 경우에는 모든 엘리먼트를 순차적으로 조회하는 형태로 구현되어 있다. 이 경우 최악의 경우 항상 O(n)이 소요된다.

## 리스트의 활용

```python

# 리스트의 선언

>>> a = list()

>>> a = []

# 초기값 선언 혹은 append()로 추가
>>> a = [1,2,3]

>>> a
[1,2,3]

>>> a.append(4)

>>> a
[1,2,3,4]

#insert()를 사용하여 인덱스를 지정하여 요소 추가

>>> a.insert(3,5) # 인덱스 3에 5를 추가

>>> a
[1,2,3,5,4]

#숫자 이외에도 문자, 불리언 등 다양한 자료형을 단일 리스트에 관리할 수 있다.

>>> a.append('안녕')

>>> a.append(True)

>>> a
[1,2,3,5,4,'안녕',True]

#값을 꺼낼때는 인덱스를 지정

>>> a[3]
5


# 슬라이싱은 파이썬의 매우 강력한 기능, 문자열과 리스트에서 유용하게 사용

>>> a[1:3] # 인덱스 1에서 인덱스 3 이전까지의 값을 가져옴
[2,3]

# 시작 인덱스 및 종료 인덱스는 생략 가능

>>> a[:3]
[1,2,3]

>>> a[4:]
[4,'안녕',True]

# 세번째 파라미터로 step 부여 가능

>>> a[1:4:2] # 세번째 파라미터가 2이므로 인덱스 1부터 3까지 2씩 건너뛰어 a[1],a[3]을 가져온다.
[2,5]

# 존재하지 않는 인덱스를 조회하면 IndexError 발생

Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list index out of range

# try 구문으로 예외처리 가능

try:
    print(a[10])
except IndexError:
    print('존재하지 않는 요소')

# 리스트에서 요소를 삭제하는 방법

>>> a
[1,2,3,5,4,'안녕',True]

>>> del a[1] # del : 인덱스를 지정하여 삭제 

>>> a
[1,3,5,4,'안녕',True]

>>> a.remove(3) # remove : 값을 지정하여 삭제

>>> a
[1,5,4,'안녕',True]

# 혹은 스택의 pop() 연산처럼 추출 : 삭제될 값을 리턴하고 삭제한다.

>>> a
[1,5,4,'안녕',True]

>>> a.pop(3)
'안녕'

>>> a
[1,5,4,True]
```

## 리스트의 특징

파이썬의 리스트는 연속된 공간에 요소를 배치하는 **배열의 장점**과 다양한 타입을 연결해 배치하는 **연결 리스트의 장점**을 모두 취한 듯한 형태를 띤다. 파이썬의 모든 자료형은 **객체**이며, 파이썬 리스트는 객체로 되어있는 모든 자료형을 포인터로 연결한다. 사실상 연결 리스트에 대한 포인터 목록을 배열 형태로 관리하고 있다. 따라서 위에서 본 것 처럼 모두 제각각인 자료형을 단일 리스트에 모두 통합해서 저장할 수 있는 것이다.

그러나 각 자료형의 크기는 저마다 서로 다르기 때문에, 이들을 연속된 메모리 공간에 할당하는 것은 불가능하다. 결국 각각의 객체에 대한 참조로 구현할 수밖에 없다. 인덱스를 조회하는 데에도 포인터의 위치를 찾아서 타입 코드를 확인하는 등 추가적인 작업이 필요하기 때문에 속도 면에서도 훨씬 불리하다. 파이썬은 강력한 기능을 위해 리스트와 객체에 대한 ***참조*** 를 택했으며 이로인해 부득이하게 ***속도*** 를 희생했다.
